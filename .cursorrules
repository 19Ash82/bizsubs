1. Be Clear and Goal-Oriented
   - Clearly describe your UI/UX objectives, features, and design inspirations.
   - Specify the platform, framework, and any design systems or libraries in use.
2. Never Rewrite Existing Code Without Confirmation
   - Do not modify or overwrite existing code unless explicit user confirmation is given.
   - Always propose changes first and wait for approval before applying them.
3. Keep Code Clean, Modular, and Well-Documented
   - Write modular, reusable components with clear, concise documentation.
   - Use inline comments for complex logic, and document all functions and modules.
   - For any code updates, comment changes with the date and a brief description (e.g., // Updated 2024-06-10: Improved validation).
4. Separate Concerns: User/Admin, Client/Server
   - Maintain separate routes and components for user and admin dashboards.
   - Clearly distinguish between client-side and server-side code, keeping them in their respective directories.
   - Ensure role-based access control is implemented and documented.
5. Prioritize Security and Best Practices (Most important)
   - Always follow secure coding practices (input validation, XSS/CSRF protection, secure authentication).
   - Implement robust error handling and user-friendly error messages.
   - Sanitize and validate all inputs on both client and server sides.
Other security protocols are in the picture below.
6. Design for Accessibility, Responsiveness, and Modern UX
   - Ensure all UI is accessible (WCAG compliance, ARIA roles, keyboard navigation).
   - Require responsive layouts and mobile-first design principles.
7. Enforce Coding Standards and Consistency
   - Adhere to established coding standards (e.g., ESLint, Prettier, TypeScript).
   - Use design tokens for consistent theming (colors, spacing, typography).
8. Iterative Development and Feedback
   - Keep each request focused on a single feature or improvement.
   - Review and test changes frequently, providing clear, actionable feedback.
9. Comprehensive Testing and Quality Assurance
   - Write unit, integration, and end-to-end tests for all components.
   - Integrate accessibility and security testing tools.
10. Document All Decisions and Changes
    - Summarize key design, architectural, and security decisions in project documentation.
    - Clearly comment all code updates with the date and reason for change.
	



## Security (Critical)
- RLS policies: user_id = auth.uid() minimum
- Team access: check team_members table
- No sensitive data in console logs
- Validate inputs client AND server side


## BizSubs Implementation Specifics
- RLS policies required on all Supabase tables (user_id = auth.uid())
- Team access: validate via team_members table relationship
- Client display pattern: "Client A +3 more" for multiple assignments
- Modal forms only (never separate pages for add/edit)
- Activity logging on all CRUD operations for team transparency
- Role-based UI rendering: hide actions for Members, don't show errors


## File Size Management
- Break large components into smaller, modular files
- Create separate component files for each homepage section
- Create separate component files for each dashboard section
- Organize components by feature: components/dashboard/, components/onboarding/, components/settings/, components/subscriptions/, etc
- Create reusable form components for user data (ProfileForm, WorkspaceForm, SubscriptionForm)
- Follow PRD.md specifications for component structure and data requirements
- Main page files should import and compose smaller components
- Each component should be self-contained with proper TypeScript interfaces
- When generating UI code, create modular structure instead of single large files
- Component files should be under 200 lines when possible
- Use proper file organization: components/[feature]/[ComponentName].tsx